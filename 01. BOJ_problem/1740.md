---
title: "1740"
categories:
  - Algorithm
tags:
  - BaekJoon
last_modified_at: 2021-10-04T23:30:00-00:30
---

# 거듭제곱

## 문제

3의 제곱수를 생각하자. 3의 0제곱, 3의 1제곱, 3의 2제곱, ... 은 순서대로 1, 3, 9, 27, ... 이 된다.

이를 바탕으로, 한 개 이상의 서로 다른 3의 제곱수의 합으로 표현되는 수를 생각할 수 있다. 예를 들어 30은 27과 3의 합이므로, 이러한 수에 포함된다.

한 개 이상의 서로 다른 3의 제곱수의 합으로 표현되는 N번째로 작은 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N이 주어진다. N은 500,000,000,000 이하의 자연수이다.

## 출력

첫째 줄에 한 개 이상의 서로 다른 3의 제곱수의 합으로 표현되는 N번째로 작은 수를 출력한다.

## 예제 입력 1

```
4
```

## 예제 출력 1

```
9
```

### 공부한 코드

```java
import java.util.*;

public class Main {

  private static final int[] arr = new int[100];

  public static int binary(long n, int pos) {
    if(n == 0) return pos;
    arr[pos] = (int) (n%2);
    return binary(n/2, pos+1);
  }

  public static long mypow(int num, int b) {
    long res = 1;
    for(int i = 1; i <= b; i++) res *= num;
    return res;
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    long n = sc.nextLong();
    long res = 0;

    int binaryCnt = binary(n, 0);
    for(int i = 0; i < binaryCnt; i++) {
      res += mypow(3, i) * arr[i];
    }
    System.out.println(res);
  }
}

```

- 이 문제는 쉽다고 생각했는데 도저히 어떻게 풀어야 할지 감이 안왔다.
- 1, 3, 9, 27, 81, 243, ... 3의 거듭제곱은 크게 어렵진 않지만,
  1, 3, 4, 9, 19, 12, 27, 28, 30, 36, ... 으로 문제가 요구하는 사항들을 어떻게 만족시켜 나가야할지 도저히 몰랐다.
  처음에 생각한 건,

  ```
  arr[0] = 1
  arr[1] = 3
  arr[2] = arr[0] + arr[1]
  arr[3] = 9
  arr[4] = arr[3] + arr[0]
  arr[5] = arr[3] + arr[1]
  arr[6] = 27
  arr[7] = arr[6] + arr[0]
  arr[8] = arr[6] + arr[1]
  arr[9] = arr[6] + arr[3]
  arr[10] = 81
  arr[11] = arr[10] + arr[0]
  arr[12] = arr[10] + arr[1]
  arr[13] = arr[10] + arr[3]
  // ...
  ```

  이라고 생각했는데, 이렇게 하니까 로직 구현에서 전혀 감이 오지 않는다.;;

- 결국 검색을 해봤는데, 이진법으로 푸는 것으로 정해져 있었다..

  | 27  | 9   | 3   | 1   | 출력값 | 입력값 |
  | --- | --- | --- | --- | ------ | ------ |
  | 0   | 0   | 0   | 1   | 1      | 1      |
  | 0   | 0   | 1   | 0   | 3      | 2      |
  | 0   | 0   | 1   | 1   | 4      | 3      |
  | 0   | 1   | 0   | 0   | 9      | 4      |
  | 0   | 1   | 0   | 1   | 10     | 5      |
  | 0   | 1   | 1   | 0   | 12     | 6      |
  | 0   | 1   | 1   | 1   | 13     | 7      |
  | 1   | 0   | 0   | 0   | 27     | 8      |
  | 1   | 0   | 0   | 1   | 28     | 9      |

오! 감이 오는 것 같다. 원래는 C++로 작성되었던 코드이고 해당 답은 내가 작성한 코드는 아니다.

일단 해당 표를 구현하는 함수부터 만들어야 하는데, `arr` 배열에 해당 입력값을 이진수로 바꾼 것을 넣어주는 것을 확인했다.
`n` 값이 0이 되어야 더 이상 나머지값이 없으므로 `n`이 0이 될 때까지 나누어주어야 한다.
그러면 입력값에 대한 `arr`의 세팅값이 모두 완료가 된다.

만약 입력값이 `4`라면, 이진수는 `0100`이므로
for 문 안에 `mypow(3, i) * arr[i]`을 풀어서 생각하면 `0*3^0 + 0*3^1 + 1*3^2`를 수행하게 된다.
`Math.pow(3, i)`는 해당 `long`타입으로 인해 런타임에러가 나는 것 같았다.

이렇게 일단 이해는 하였으나, 뭔가 직접 짜보려고 하니 어려웠던 것 같다.
