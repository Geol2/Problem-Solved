# 최단거리

다익스트라 알고리즘, 플로이드 워셜 알고리즘을 다룬다

## 다익스트라 알고리즘

그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구하는 알고리즘

GPS 소프트웨어의 기본 알고리즘으로 채택되는 편

### 다양한 문제 상황
- 한 지점에서 다른 한 지점까지의 최단 경로
- 한 지점에서 다른 모든 지점까지의 최단 경로
- 모든 지점에서 다른 모든 지점까지의 최단 경로

### 동작과정
1. 출발 노드를 지정
2. 최단 거리 테이블을 초기화
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5. 3번과 4번을 반복한다

- 단계마다 최단 거리를 가지는 노드를 하나씩 반복적으로 선택한다

구현하기 쉽지만 느리게 동작하는 방법보단 조금 까다롭더라도 빠르게 동작하는 코드를 연습하는 것이 좋다

책을 보는 것이 더 편하다, 출발 노드 &rightarrow; 도착노드(가중치)로 두어서 그려보면서 보자

- 1 &rightarrow; 2(2), 3(5), 4(3)번 노드
- 2 &rightarrow; 3(3), 4(2)번 노드
- 3 &rightarrow; 2(3), 6(5)번 노드
- 4 &rightarrow; 3(3), 5(1)번 노드
- 5 &rightarrow; 3(1), 6(2)번 노드
- 6 &rightarrow; X

1. 초기

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|----|------|-----|--- |
| 거리    | 0 | 무한 | 무한 | 무한 | 무한 | 무한 |

2. 출발 노드 1번

1번 노드까지 오는 비용은 0이므로 2(0+2), 5(0+5), 1(0+1)

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|-----|------|-----|--- |
| 거리    | 0 |  2  |  5  |  1   | 무한 | 무한 |

3. 출발 노드 4번

4번 노드까지 오는 비용은 1이므로, 1번 노드에서 4번을 통해서 3, 5번으로 가는 비용은 (1+3) = 4, (1+1) = 2이다

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|-----|------|----|--- |
| 거리    | 0 |  2  |  4  |  1   | 2  | 무한 |

4. 출발 노드 2번

2번에서 3번으로 이동할 때, 5(2+3)의 비용이 발생되지만 이미 4이므로 갱신되지 않는다

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|-----|------|----|--- |
| 거리    | 0 |  2  |  4  |  1   | 2  | 무한 |

5. 출발 노드 5번

5번에서 3, 6번으로 갈 수 있는데, 5번까지 가는 최단거리가 2이므로 5번에서 3번으로 가는 거리인 1을 더한 3이 더 작으므로 갱신된다

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|-----|------|----|--- |
| 거리    | 0 |  2  |  3  |  1   | 2  | 4 |

6. 출발 노드 3번

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|-----|------|----|--- |
| 거리    | 0 |  2  |  3  |  1   | 2  |  4 |

7. 출발 노드 6번

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|-----|------|----|--- |
| 거리    | 0 |  2  |  3  |  1   | 2  |  4 |

1번 노드로부터 출발 했을 때, 2, 3, 4, 5, 6번 노드까지 가기 위한 최단 경로는 2, 3, 1, 2

## 방법 1
- 시간복잡도는 $ O(V^2)$ (단, $ V $ 는 노드)

```python
import sys
input = sys.stdin.readline
INF = int(1e9)

n, m = map(int, input().split())
start = int(input())
graph = [[] for i in range(n + 1)]
visited = [False] * (n + 1)
distance = [INF] * (n + 1)

for _ in range(m):
  a, b, c = map(int, input().split())
  graph[a].append((b, c))

def get_smallest_node():
  min_value = INF
  index = 0
  for i in range(1, n + 1):
    if distance[i] < min_value and not visited[i]:
      min_value = distance[i]
      index = i
  return index


def dijkstra(start):
  distance[start] = 0
  visited[start] = True
  for j in graph[start]:
    distance[j[0]] = j[1]
  for i in range(n-1):
    now = get_smallest_node()
    visited[now] = True
    for j in graph[now]:
      cost = distance[now] + j[1]
      if cost < distance[j[0]]:
        distance[j[0]] = cost

dijkstra(start)

for i in range(1, n + 1):
  if distance[i] == INF:
    print("INFINITY")
  else:
    print(distance[i])
```

## 방법2
- 시간복잡도 : $ O(E logV) $ 로 개선된다

1. 출발 노드 1

| 노드번호 | 1 |  2  |  3  |  4  |  5  |  6 |
|--------|---|-----|----|------|-----|--- |
| 거리    | 0 | 무한 | 무한 | 무한 | 무한 | 무한 |

| 우선순위 큐 | (거리:0, 노드:1) |
|----------|----------------|

2. 출발 노드 4

꺼낸 원소: (거리:0, 노드:1)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|--- |
| 거리    | 0 | 2   | 5   | 1    | 무한 | 무한 |

| 우선순위 큐 | (거리:1, 노드:4) (거리:2, 노드:2) (거리:5, 노드:3) |
|----------|----------------|

-----

꺼낸 원소: (거리:1, 노드:4)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|--- |
| 거리    | 0 | 2   | 4   | 1    | 2   | 무한 |

| 우선순위 큐 | (거리:2, 노드:2) (거리:2, 노드:5) (거리:4, 노드:3) (거리:5, 노드:3)|
|----------|----------------|

3. 출발 노드 2

꺼낸 원소: (거리:2, 노드:2)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|--- |
| 거리    | 0 | 2   | 4   | 1    | 2   | 무한 |

| 우선순위 큐 | (거리:2, 노드:5) (거리:4, 노드:3) (거리:5, 노드:3)|
|----------|----------------|

4. 출발 노드 5

꺼낸 원소: (거리:2, 노드:5)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|----|
| 거리    | 0 | 2   | 3   | 1    | 2   | 4  |

| 우선순위 큐 | (거리:3, 노드:3) (거리:4, 노드:3) (거리:4, 노드:6) (거리:5, 노드:3) |
|----------|----------------|

5. 출발 노드 3

꺼낸 원소: (거리:3, 노드:3)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|----|
| 거리    | 0 | 2   | 3   | 1    | 2   | 4  |

| 우선순위 큐 | (거리:4, 노드:3) (거리:4, 노드:6) (거리:5, 노드:3) |
|----------|----------------|

-----

꺼낸 원소: (거리:4, 노드:3)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|----|
| 거리    | 0 | 2   | 3   | 1    | 2   | 4  |

| 우선순위 큐 | (거리:4, 노드:6) (거리:5, 노드:3) |
|----------|----------------|

6. 출발 노드 6

꺼낸 원소: (거리:4, 노드:6)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|----|
| 거리    | 0 | 2   | 3   | 1    | 2   | 4  |

| 우선순위 큐 | (거리:5, 노드:3) |
|----------|----------------|

7. 출발 노드 6

꺼낸 원소: (거리:4, 노드:6)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|----|
| 거리    | 0 | 2   | 3   | 1    | 2   | 4  |

| 우선순위 큐 | (거리:5, 노드:3) |
|----------|----------------|

8. 이미 처리된 노드

꺼낸 원소: (거리:5, 노드:3)
| 노드번호 | 1 |  2  |  3  |  4   |  5  |  6 |
|--------|---|-----|-----|------|-----|----|
| 거리    | 0 | 2   | 3   | 1    | 2   | 4  |

| 우선순위 큐 |                |
|----------|----------------|

풀이

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

n, m = map(int, input().split())
start = int(input())
graph = [[] for i in range(n + 1)]
visited = [False] * (n + 1)
distance = [INF] * (n + 1)

for _ in range(m):
  a, b, c = map(int, input().split())
  graph[a].append((b, c))

def dijkstra(start):
  q = []
  heapq.heappush(q, (0, start))
  distance[start] = 0
  while q:
    dist, now = heapq.heappop(q)
    if distance[now] < dist:
      continue
    for i in graph[now]:
      cost = dist + i[1]
      if cost < distance[i[0]]:
        distance[i[0]] = cost
        heapq.heappush(q, (cost, i[0]))

dijkstra(start)

for i in range(1, n + 1):
  if distance[i] == INF:
    print("INFINITY")
  else:
    print(distance[i])
```

## 플로이드 워셜 알고리즘

모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우 사용할 수 있는 알고리즘

- 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다
- 시간복잡도 : $ O(N^2) $

$ D_{ab} = min(D_{ab}, D_{ak} + D_{kb}) $

$ D_{ab} $ 는 a에서 b로 가는 최단 거리

A에서 B로 가는 최소 비용과 A에서 K를 거쳐 B로 가는 비용 중 작은 것으로 갱신

| 출발\도착 | 1번 | 2번 | 3번 | 4번 |
|--------|-----|----|-----|----|
|   1번   | 0  |  4  | 무한 | 6  |
|   2번   | 3  |  0  |  7 | 무한 |
|   3번   | 5  | 무한 |  0 | 4  |
|   4번   | 무한| 무한 |  2 | 0  |

1번 노드를 거쳐 가는 경우

$ D_{23} = min(D_{23}, D_{21} + D_{13}) $

$ D_{24} = min(D_{24}, D_{21} + D_{14}) $

$ D_{32} = min(D_{32}, D_{31} + D_{12}) $

$ D_{34} = min(D_{34}, D_{31} + D_{14}) $

$ D_{42} = min(D_{42}, D_{41} + D_{12}) $

$ D_{43} = min(D_{43}, D_{41} + D_{13}) $

예를 들어, 2번에서 3번으로 가는 비용보다 2번에서 1번을 거쳐 3번으로 가는 비용이 적다면, 그것으로 갱신을 해주면 된다.

 출발\도착 | 1번 | 2번 | 3번 | 4번 |
|--------|-----|----|-----|----|
|   1번   | 0  |  4  | 무한 | 6  |
|   2번   | 3  |  0  |  7 | 9 |
|   3번   | 5  |  9  |  0 | 4  |
|   4번   | 무한| 무한 |  2 | 0  |

거쳐가는 경우 가중치가 적으면 갱신하고 없거나 크면 갱신하지 않으면 된다

이런 식으로 각 2번, 3번, 4번 노드별로 거쳐가는 비용을 계산해가는 방식으로 해본다

최종 표는 다음과 같다

| 출발 \ 도착 | 1번 | 2번 | 3번 | 4번 |
|-----------|-----|----|-----|----|
|    1번    | 0  |  4  |  8  | 6  |
|    2번    | 3  |  0  |  7  | 9  |
|    3번    | 5  |  9  |  0  | 4  |
|    4번    | 7  | 11  |  2  | 0  |

```python
INF = int(1e9)

n = int(input())
m = int(input())
graph = [[INF] * (n + 1) for _ in range(n + 1)]

for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a][b] = c

for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

for a in range(1, n + 1):
    for b in range(1, n + 1):
        if graph[a][b] == INF:
            print("INFINITY", end=" ")
        else:
            print(graph[a][b], end=" ")
    print()
```
