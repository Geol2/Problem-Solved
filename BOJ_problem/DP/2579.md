```c++
#include<iostream>
using namespace std;

int main() {
	int S[301] = {0,};
	int D[301][3] = { 0, };

	int n;
	int num;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> num;
		S[i] = num;
	}

	D[1][1] = S[1];
	D[1][2] = 0;
	D[2][1] = S[2];
	D[2][2] = S[1] + S[2];

	for (int i = 3; i <= n; i++) {
		D[i][1] = max(D[i - 2][1], D[i - 2][2]) + S[i];
		D[i][2] = D[i - 1][1] + S[i];
	}

	cout << max(D[n][0], D[n][1]) << endl;
	return 0;
}
```
|        |  |    |    |    |    |    |    |
|--------|--|----|----|----|----|----|----|
|S[i]    | 0|  10|  20|  25|  25|  10|  20|


|D[i][j] | 0|   1|   2|   3|   4|   5|   6|
|--------|--|----|----|----|----|----|----|
|1       | 0|  10|  20|  35|  55|  45|  75|
|2       | 0|   0|  30|  45|  55|  65|  65|


## D[i][j] 정의

D[i][j] 은 현재까지 j개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최대값, 단 i번째 계단은 반드시 밟아야 함

- d[i][1] 은 현재까지 1개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최대값!

- D[i][2] 은 현재까지 2개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최대값!

## S[i][j] 정의

계단의 값이다.

## 로직

1. D[1][1] : S[1] 의 값을 넣어줌, 현재까지 1개의 계단을 연속해서 밟고 첫 번째 계단에 올라옴

2. D[1][2] : 현재까지 2개의 계단을 연속해서 밟고 첫 번째 계단에 올라올 경우는 없으므로 `0`을 넣음

3. D[2][1] : S[2] 의 값을 넣어줌, 이것은 한 번에 두 번째 계단에 올라왔음을 뜻함

4. D[2][2] : S[1] + S[2] 의 값을 넣어줌, 이것은 첫 번째와 두 번째 계단을 통해 올라왔음을 뜻함

5. D[3]부터는 D[3][1], D[3][2] 둘 다 정답이 될 수도 있는데 어떻게 규칙을 찾아줄까? 

6. D[3][1]
  - 1개의 계단을 연속해서 밟고 세 번째 계단에 섰을 경우인데, 연속된 세 계단을 밟을 수 없어서 D[2][]가 아닌 D[1][1]와 D[1][2]의 최대값과 S[i]를 더한다.

7. D[3][2]
  - 2개의 계단을 연속해서 밟고 세 번째 계단까지 올라섰을 경우이므로, D[2][2]를 계산하면 세 개의 계단을 연속해서 밟았다는 것이 되서 D[2][1] 을 계산해주는 것이 적절하다. 

8. i의 값에 따라 D[i][1]와 D[i][2] 중 최대값을 출력하고 종료시키면 끝난다.